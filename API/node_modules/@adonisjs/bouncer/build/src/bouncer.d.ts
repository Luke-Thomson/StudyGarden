import type { EmitterLike } from '@adonisjs/core/types/events';
import { type ContainerResolver } from '@adonisjs/core/container';
import { AuthorizationResponse } from './response.js';
import { ability as createAbility } from './ability.js';
import { AbilitiesBuilder } from './abilities_builder.js';
import { PolicyAuthorizer } from './policy_authorizer.js';
import type { LazyImport, Constructor, BouncerEvents, BouncerAbility, ResponseBuilder, UnWrapLazyImport, BouncerAuthorizer, AuthorizerResponse, NarrowAbilitiesForAUser } from './types.js';
/**
 * Bouncer exposes the API to evaluate bouncer abilities and policies to
 * verify if a user is authorized to perform the given action
 */
export declare class Bouncer<User extends Record<any, any>, Abilities extends Record<string, BouncerAbility<any>> | undefined = undefined, Policies extends Record<string, LazyImport<Constructor<any>>> | undefined = undefined> {
    #private;
    /**
     * Response builder is used to normalize bouncer responses
     */
    static responseBuilder: ResponseBuilder;
    /**
     * Define an ability using the AbilityBuilder
     */
    static define<Name extends string, Authorizer extends BouncerAuthorizer<any>>(name: Name, authorizer: Authorizer, options?: {
        allowGuest: boolean;
    }): AbilitiesBuilder<{ [K in Name]: Authorizer extends (user: infer User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse> ? {
        allowGuest: false;
        original: Authorizer;
        execute(user: User | null, ...args: Args): ReturnType<Authorizer>;
    } : never; }>;
    /**
     * Emitter to emit events
     */
    static emitter?: EmitterLike<BouncerEvents>;
    /**
     * Define a bouncer ability from a callback
     */
    static ability: typeof createAbility;
    /**
     * Pre-defined abilities
     */
    abilities?: Abilities;
    /**
     * Pre-defined policies
     */
    policies?: Policies;
    /**
     * An object with helpers to be shared with Edge for
     * performing authorization.
     */
    edgeHelpers: {
        bouncer: {
            parent: Bouncer<User, Abilities, Policies>;
            can(action: string, ...args: any[]): Promise<boolean>;
            cannot(action: string, ...args: any[]): Promise<boolean>;
        };
    };
    constructor(userOrResolver: User | (() => User | null) | null, abilities?: Abilities, policies?: Policies);
    /**
     * Returns an instance of PolicyAuthorizer. PolicyAuthorizer is
     * used to authorize user and actions using a given policy
     */
    with<Policy extends keyof Policies>(policy: Policy): Policies extends Record<string, LazyImport<Constructor<any>>> ? PolicyAuthorizer<User, UnWrapLazyImport<Policies[Policy]>> : never;
    with<Policy extends Constructor<any>>(policy: Policy): PolicyAuthorizer<User, Policy>;
    /**
     * Set a container resolver to use for resolving policies
     */
    setContainerResolver(containerResolver?: ContainerResolver<any>): this;
    /**
     * Execute an ability by reference
     */
    execute<Ability extends BouncerAbility<User>>(ability: Ability, ...args: Ability extends {
        original: (user: User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse>;
    } ? Args : never): Promise<AuthorizationResponse>;
    /**
     * Execute an ability from the list of pre-defined abilities
     */
    execute<Ability extends NarrowAbilitiesForAUser<User, Abilities>>(ability: Ability, ...args: Abilities[Ability] extends {
        original: (user: User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse>;
    } ? Args : never): Promise<AuthorizationResponse>;
    /**
     * Check if a user is allowed to perform an action using
     * the ability provided by reference
     */
    allows<Ability extends BouncerAbility<User>>(ability: Ability, ...args: Ability extends {
        original: (user: User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse>;
    } ? Args : never): Promise<boolean>;
    /**
     * Check if a user is allowed to perform an action using
     * the ability from the pre-defined list of abilities
     */
    allows<Ability extends NarrowAbilitiesForAUser<User, Abilities>>(ability: Ability, ...args: Abilities[Ability] extends {
        original: (user: User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse>;
    } ? Args : never): Promise<boolean>;
    /**
     * Check if a user is denied from performing an action using
     * the ability provided by reference
     */
    denies<Action extends BouncerAbility<User>>(action: Action, ...args: Action extends {
        original: (user: User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse>;
    } ? Args : never): Promise<boolean>;
    /**
     * Check if a user is denied from performing an action using
     * the ability from the pre-defined list of abilities
     */
    denies<Action extends NarrowAbilitiesForAUser<User, Abilities>>(action: Action, ...args: Abilities[Action] extends {
        original: (user: User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse>;
    } ? Args : never): Promise<boolean>;
    /**
     * Authorize a user against for a given ability
     *
     * @throws AuthorizationException
     */
    authorize<Action extends BouncerAbility<User>>(action: Action, ...args: Action extends {
        original: (user: User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse>;
    } ? Args : never): Promise<void>;
    /**
     * Authorize a user against a given ability
     *
     * @throws {@link E_AUTHORIZATION_FAILURE}
     */
    authorize<Ability extends NarrowAbilitiesForAUser<User, Abilities>>(ability: Ability, ...args: Abilities[Ability] extends {
        original: (user: User, ...args: infer Args) => AuthorizerResponse | Promise<AuthorizerResponse>;
    } ? Args : never): Promise<void>;
    /**
     * Create AuthorizationResponse to deny access
     */
    deny(message: string, status?: number): AuthorizationResponse;
}
